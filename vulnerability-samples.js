/*
 * vulnerability-samples.js
 * Ejemplos de vulnerabilidades detectables por SonarQube
 */

// 1. SQL Injection
function getUserById(id) {
  // BUG: Inyección SQL al concatenar directamente
  const query = "SELECT * FROM users WHERE id = " + id;
  db.execute(query);
}
// SOLUCIÓN: utilizar consultas parametrizadas, por ejemplo:
// const query = "SELECT * FROM users WHERE id = ?";
// db.execute(query, [id]);

// 2. XSS - Cross-Site Scripting
function renderComment(comment) {
  // BUG: inserción directa en innerHTML
  document.getElementById('comments').innerHTML = comment;
}
// SOLUCIÓN: escapar o sanitizar la entrada antes de inyectar en el DOM:
// document.getElementById('comments').textContent = comment;

// 3. Hardcoded credentials
const DB_PASSWORD = 'P@ssw0rd123';
// SOLUCIÓN: almacenar credenciales en variables de entorno o vault y no en el código.

// 4. Command Injection
const { exec } = require('child_process');
function deleteFile(filename) {
  // BUG: inyección de comandos al usar exec con entrada no confiable
  exec('rm ' + filename);
}
// SOLUCIÓN: usar APIs seguras de filesystem o validar estrictamente el nombre de archivo:
// const safeName = path.basename(filename);
// fs.unlinkSync(safeName);

// 5. Insecure Randomness
function generateToken() {
  // BUG: uso de Math.random para tokens de autenticación
  return Math.floor(Math.random() * 1000000).toString();
}
// SOLUCIÓN: usar crypto.randomBytes o un generador criptográficamente seguro:
// return crypto.randomBytes(16).toString('hex');

// 6. Weak Hash Algorithm
const crypto = require('crypto');
function hashPassword(password) {
  // BUG: uso de MD5, algoritmo obsoleto
  return crypto.createHash('md5').update(password).digest('hex');
}
// SOLUCIÓN: usar algoritmos fuertes como bcrypt, Argon2 o SHA-256 con SALT:
// return crypto.createHash('sha256').update(password + salt).digest('hex');

// 7. SSL Certificate Validation Disabled
const https = require('https');
const agent = new https.Agent({
  rejectUnauthorized: false // BUG: permite certificados inválidos
});
https.get('https://api.example.com', { agent }, res => {
  // ...
});
// SOLUCIÓN: eliminar rejectUnauthorized: false y confiar en certificados válidos.

// 8. Path Traversal
const fs = require('fs');
function readFile(filePath) {
  // BUG: posibilidad de traversal al no validar el path
  return fs.readFileSync(filePath, 'utf8');
}
// SOLUCIÓN: normalizar y restringir la ruta, por ejemplo:
// const safePath = path.normalize(filePath).replace(/^(\.{2}(\/|\\|$))+/g, '');
// return fs.readFileSync(path.join(baseDir, safePath), 'utf8');

// 9. Server-Side Request Forgery (SSRF)
const axios = require('axios');
async function fetchUrl(url) {
  // BUG: no se valida la URL de destino
  const resp = await axios.get(url);
  return resp.data;
}
// SOLUCIÓN: validar la URL contra una lista blanca de dominios permitidos antes de solicitar.

// 10. Missing CSRF Protection
// En un endpoint Express:
// app.post('/update', (req, res) => {
//   BUG: no verifica token CSRF
//   updateUser(req.body);
//   res.sendStatus(200);
// });
// SOLUCIÓN: implementar middleware de CSRF (p.ej. csurf) y verificar el token en cada petición.
